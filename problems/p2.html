<!DOCTYPE html>
<html>

<head>
<meta charset='utf-8' />
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<meta name="description" content="Project Euler : " />
<link rel="stylesheet" type="text/css" media="screen" href="../stylesheets/stylesheet.css">
<title>All the problems of Project Euler</title>
</head>

<body>

<!-- HEADER -->
<div id="header_wrap" class="outer">
  <header class="inner">
    <a id="forkme_banner" href="https://github.com/lyuehh/Project_Euler">View on GitHub</a>

    <h1 id="project_title"><a href="../index.html">Project Euler</a></h1>
    <h2 id="project_tagline"></h2>

    <section id="downloads">
      <a class="zip_download_link" href="https://github.com/lyuehh/Project_Euler/zipball/master">Download this project as a .zip file</a>
      <a class="tar_download_link" href="https://github.com/lyuehh/Project_Euler/tarball/master">Download this project as a tar.gz file</a>
    </section>
  </header>
</div>

<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner">
    <h1>Problem 2</h1>
    <article>
      <h2>题目</h2>
<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.  </p>
<p>对于数列f(n):
  f(1) =1,f(2) =2
  f(n) =f(n-1)+f(n-2) (n&gt;2)
求数列f(n)中不大于4000000且为偶数项数之和。</p>
<h2>答案</h2>
<p>4613732</p>


        <h3><a href="#clojure">clojure</a></h3>
        <pre name="clojure" id="clojure" class="prettyprint">
 ;;lazy..
(defn lazy-seq-fibo
  ([]
    (concat [0 1] (lazy-seq-fibo 0 1)))
  ([a b]
    (let [n (+ a b)]
      (lazy-seq
        (cons n (lazy-seq-fibo b n))))))

;;(print (drop 1 (take 10 (lazy-seq-fibo))))
(println (reduce + (filter even?
  (take-while (fn [x] (< x 4000000)) (lazy-seq-fibo)))))

;; 另一种简洁的方案
(defn fibo []
    (map first (iterate (fn [[a b]] [b (+ a b)]) [0 1])))

;(println (reduce + (for [n (fibo) :when (even? n) :while (> 4000000 n)] n)))

        </pre>
        <h3><a href="#coffeescript">coffeescript</a></h3>
        <pre name="coffeescript" id="coffeescript" class="prettyprint">
 # 递归版本
fib = (n) ->
  if n < 2 then n else fib(n-1) + fib(n-2)

# 迭代版本
fib2 = (n) ->
  for i in [0..n]
    if i is 0
      first = 1
      second = 0
    else
      add = first + second
      first = second
      second = add
  return add

## 没有lazy特性, 我们取1到40
ret = [1..40].map((n) ->
  return fib2(n)
).filter((n) ->
  return n < 4000000
).filter((n) ->
  return n % 2 is 0
).reduce((memo, i) ->
  return memo + i
)
console.log ret

        </pre>
        <h3><a href="#erlang">erlang</a></h3>
        <pre name="erlang" id="erlang" class="prettyprint">
 #!/usr/bin/env escript

%% 递归版本
%% fib(1) -> 1;
%% fib(2) -> 1;
%% fib(N) -> fib(N-1) + fib(N-2).

%% 尾递归优化版本
fib2(N) -> fib2_iter(1,0,N).
fib2_iter(A, B, N) ->
  if
    N == 0 -> B;
    true -> fib2_iter(A+B, A, N-1)
  end.

%% 应该可以惰性求值,但是不会...
main(_) ->
  io:format("~p~n",
    [lists:foldl(fun(X, Sum) -> X + Sum end, 0,
        lists:filter(fun(X) -> (X rem 2) =:= 0 end,
          lists:filter(fun(X) -> X < 4000000 end,
            [fib2(X) || X <- lists:seq(1,40)])))]).

        </pre>
        <h3><a href="#haskell">haskell</a></h3>
        <pre name="haskell" id="haskell" class="prettyprint">
 module Main where

-- 递归版本
fib n = if n < 2 then n else fib(n-1) + fib(n-2)

-- 尾递归版本
fib2_iter (x, y, 0) = (x, y, 0)
fib2_iter (x, y, z) = fib2_iter(y, x + y, z - 1)

fib2_ret (x, y, z) = x

fib2 x = fib2_ret(fib2_iter(0, 1, x))

-- 惰性求值
myRange start step = start:(myRange (start + step) step)

-- 我的版本...
main = print(sum [x | x <- takeWhile (< 4000000)
  (map (\x -> fib2(x)) [x | x <- (myRange 1 1)]), even x])

-- haskell 社区wiki 简洁版本, r即为结果
r = sum [ x | x <- takeWhile (<= 4000000) fibs, even x]
  where
    fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
-- main = print(r)

        </pre>
        <h3><a href="#io">io</a></h3>
        <pre name="io" id="io" class="prettyprint">
 
// 递归版本
fib := method(n,
  if(n<2, n, fib(n-1) + fib(n-2))
)

// 迭代版本
fib2 := method(n,
  first := 0
  second := 0
  all := 0
  for(i, 0, n,
    if(i==0,
        first := 1
        second := 0,
        all = first + second
        first = second
        second = all
      )
    )
    return all
)

// 没有lazy
Range
1 to(40) asList  map(i, v, fib2(v)) select(i, v, v < 4000000) select(i, v, v % 2 == 0) sum println

        </pre>
        <h3><a href="#javascript">javascript</a></h3>
        <pre name="javascript" id="javascript" class="prettyprint">
 
// 递归版本,效率很差
function fib(n) {
  if(n < 2) {
    return n;
  } else {
    return fib(n-1) + fib(n-2);
  }
}

// 非递归版本
function fib2(n) {
  var first, second, add;
  for(var i = 0;i < n;i++) {
    if(i === 0) {
      first = 1;
      second = 0;
    }
    add = first + second;
    first = second;
    second = add;
  }
  return add;
}

// 没有lazy特性,取1到40
function p2() {
  var arr = [];
  for(var i=1;i<40;i++) {
    arr.push(i);
  }
  var ret = arr.map(function(n) {
    return fib2(n);
  }).filter(function(n) {
    return n < 4000000;
  }).filter(function(n) {
    return n % 2 === 0;
  }).reduce(function(memo, n) {
    return memo + n;
  }, 0);
  return ret;
}
console.log(p2());

        </pre>
        <h3><a href="#lua">lua</a></h3>
        <pre name="lua" id="lua" class="prettyprint">
 _ = require "underscore"

-- 递归版本
function fib(n)
  if n < 2 then
    return n
  else
    return fib(n-1) + fib(n-2)
  end
end

-- 迭代版本
function fib2(n)
  i = 0
  local first = 0
  local second = 0
  local add = 0
  while i <= n do
    if i == 0 then
      first = 1
      second = 0
    else
      add = first + second
      first = second
      second = add
    end
    i = i + 1
  end
  return add
end

print(_.reduce(_.select(_.select(_.map(_.range(0,40):to_array(),
  function(i) return fib2(i) end),
    function(i) return i < 4000000 end),
      function(i) return i % 2 == 0 end),0,
        function(memo, i) return memo + i end))

        </pre>
        <h3><a href="#newlisp">newlisp</a></h3>
        <pre name="newlisp" id="newlisp" class="prettyprint">
 ;; 递归版本
(define (fib n) (if (< n 2) n 
                  (+ (fib (- n 1)) (fib (- n 2)))))

;; 尾递归优化版本
(define (fib2 n) (fib2_iter 1 0 n))
(define (fib2_iter a b n) 
  (if (= n 0) b (fib2_iter (+ a b) a (- n 1))))

(println (apply + (filter (lambda (x) 
                            (= (% x 2) 0)) (filter (lambda (x) (< x 4000000)) 
                            (map (lambda (x) (fib2 x)) (sequence 1 40))))))
(exit)

        </pre>
        <h3><a href="#ruby">ruby</a></h3>
        <pre name="ruby" id="ruby" class="prettyprint">
 
# 递归版本,效率很差
def fib(n)
  if n < 2
    return n
  else
    return fib(n-1) + fib(n-2)
  end
end
# puts (1..Float::INFINITY).lazy.map{|n| fib(n) }.take_while{|n| n < 4000000}.select{|x| x % 2 == 0}.reduce{|i,a| i + a}

# 非递归版本
def fib2(n)
  (0..n).inject([1,0]) {|(a,b), _| [b, a+b]}[0]
end
# puts (1..Float::INFINITY).lazy.map{|n| fib2(n) }.take_while{|n| n < 4000000}.select{|x| x % 2 == 0}.reduce(:+)

# 结合上面,可以写个一行版本的
puts (1..Float::INFINITY).lazy.map{|n| (0..n).inject([1,0]) {|(a,b), _| [b, a+b]}[0] }
  .take_while{|n| n < 4000000}.select{|x| x % 2 == 0}.reduce(:+)


        </pre>
        <h3><a href="#scala">scala</a></h3>
        <pre name="scala" id="scala" class="prettyprint">
 
// 注释
var fib:Stream[Int] = Stream.cons(1, 
  Stream.cons(2, fib.zip(fib.tail).map{case(x,y) => x + y}))
println(fib.takeWhile{_ <= 4000000}.filter(_ % 2 == 0).foldLeft(0){_ + _})

        </pre>
    </article>
    <aside>
      <ul>
          <li><a href="p1.html">Problem 1</a></li>
          <li><a href="p2.html">Problem 2</a></li>
          <li><a href="p3.html">Problem 3</a></li>
      </ul>
    </aside>
    <div class="cb"></div>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'projecteuler'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </section>
</div>

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    <p class="copyright">Project Euler maintained by <a href="https://github.com/lyuehh">lyuehh</a></p>
    <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
  </footer>
</div>
<script type='text/javascript' src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
</body>
</html>
